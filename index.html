<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>hero</title>
	</head>
	<style>
	    body,html{width: 100%;height: 100%;margin: 0;padding: 0;overflow: hidden;}
		#world{
			width: 100%;
			height: 100%;
			background-color: white;
		}
		#title{
			position: absolute;
			top: 0;
			left: 0;
			font-size: 30px;
			font-family:  "bodoni mt black";
			color: white;
			text-shadow: 3px 3px 5px #000;
		}
		#github{
			display: block;
			position: absolute;
			bottom: 50px;
			left: 20px;
			font-size: 22px;
			font-family: "微软雅黑";
			color: white;
			text-shadow: 3px 3px 1px #000;
			text-decoration: none;
			background-color: black;
			padding: 0 5px;
			border-radius: 5px;
			font-size: 16px;
		}
	</style>
	<body>
		<script type="text/javascript" src="js/three.js" ></script>
		<script type="text/javascript" src="js/OBJLoader.js" ></script>
		<script type="text/javascript" src="js/MTLLoader.js" ></script>
		<script type="text/javascript" src="js/TextureLoader.js" ></script>
		<script type="text/javascript" src="js/tween.js" ></script>
		<script type="text/javascript" src="js/Cloth.js" ></script>
		<div id="world">
			<!--画布-->
		</div>
		<div id="title">
			Lab-6-clap
		</div>
		<a id="github" href="https://github.com/johanzhu" target="_blank">
		    Follow me on github
		</a>
		
		<!--定义UV-->
		<script type="x-shader/x-fragment" id="fragmentShaderDepth">
			#include <packing>
			uniform sampler2D texture;
			varying vec2 vUV;
			void main() {
				vec4 pixel = texture2D( texture, vUV );
				if ( pixel.a < 0.5 ) discard;
				gl_FragData[ 0 ] = packDepthToRGBA( gl_FragCoord.z );
			}
			
		</script>
		<!--定义shader-->
		<script type="x-shader/x-vertex" id="vertexShaderDepth">
			varying vec2 vUV;
			void main() {
				vUV = 0.75 * uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>
		<!--建立场景-->
		<script>
			var scene,
			camera,
			renderer;
			
			var clothGeometry; 
			
			scene = new THREE.Scene();
		    camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,20000);
			camera.position.set(0,-200,-10000);
			camera.rotation.y = Math.PI;
			camera.lookAt(new THREE.Vector3(0,0,0));
		    renderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
		    renderer.setSize(window.innerWidth,window.innerHeight);
		    renderer.shadowMapEnabled = true;
		    var container =  document.getElementById('world');
		    container.appendChild(renderer.domElement);
		    window.addEventListener('resize',onWindowResize,false);
		    function onWindowResize(){
	           WIDTH=window.innerWidth;
	           HEIGHT=window.innerHeight;
               renderer.setSize(WIDTH, HEIGHT);
               camera.aspect = WIDTH / HEIGHT;
               camera.updateProjectionMatrix();
            }
		/*灯光*/   
		    var ambient = new THREE.AmbientLight( 0x444444 );
			scene.add( ambient );
			var directionalLight = new THREE.SpotLight( 0xffeedd );
			directionalLight.position.set( 100, 1, 10 );
			directionalLight.lookAt(new THREE.Vector3(0,0,0));
			directionalLight.intensity = 3.5;
			scene.add( directionalLight );
		
            
		/*场景模型*/	
	    var onProgress = function ( xhr ) {
		if ( xhr.lengthComputable ) {
			var percentComplete = xhr.loaded / xhr.total * 100;
					}
		};
        var onError = function ( xhr ) { };
        var mtlLoader1 = new THREE.MTLLoader();
            mtlLoader1.setPath( 'img/' );
            mtlLoader1.load( '背影.mtl', function( materials ) {materials.preload();
        var objLoader1 = new THREE.OBJLoader();
            objLoader1.setMaterials( materials );
            objLoader1.setPath( 'img/' );
            objLoader1.load( '背影.obj', function ( object ) {
		      scene.add( object );
		    }, onProgress, onError );});
	    /*绘制披风*/
	   pins = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];//定义钉子
	   /*定义披风贴图*/
	   var loader = new THREE.TextureLoader();
	   var clothTexture = loader.load( './img/clap.png' );
	   clothTexture.wrapS = clothTexture.wrapT = THREE.RepeatWrapping;
		clothTexture.anisotropy = 16;

		var clothMaterial = new THREE.MeshPhongMaterial( {
		  specular: 0x030303,
		  map: clothTexture,
		  side: THREE.DoubleSide,
		  alphaTest: 0.5
		  } );

		/*定义披风几何体*/
		clothGeometry = new THREE.ParametricGeometry( clothFunction, cloth.w, cloth.h );
		clothGeometry.dynamic = true;

		var uniforms = { texture:  { value: clothTexture } };
		var vertexShader = document.getElementById( 'vertexShaderDepth' ).textContent;
		var fragmentShader = document.getElementById( 'fragmentShaderDepth' ).textContent;

		/*定义披风模型*/
		object = new THREE.Mesh( clothGeometry, clothMaterial );
		object.position.set( 0, -850, -150 );
		object.castShadow = true;
		scene.add( object );

		object.customDepthMaterial = new THREE.ShaderMaterial( {
		  uniforms: uniforms,
		  vertexShader: vertexShader,
		  fragmentShader: fragmentShader,
		  side: THREE.DoubleSide
		} );
		
	    
		/*生成黑雨*/	
		function createParticles(size, transparent, opacity, sizeAttenuation, color) {
            var loader = new THREE.TextureLoader();
            texture = loader.load("./img/snow.png");
            geom = new THREE.Geometry();
            var material = new THREE.PointsMaterial({
                size: size,
                transparent: transparent,
                opacity: opacity,
                map: texture,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: sizeAttenuation,
                color: color});
            var range = 2000;//设置雨掉落的范围
            /*随机摆放雨滴粒子*/
            for (var i = 0; i < 1200; i++) {
                var particle = new THREE.Vector3(
                        Math.random() * range - range / 2,
                        2*Math.random() * range,
                        Math.random() * range - range / 2
                );
                particle.velocityY = 20*Math.random();
                particle.velocityX = 20;
                geom.vertices.push(particle);
            }
            system = new THREE.Points(geom, material);
            system.position.set(0,-750,-9000);
            system.rotation.z = -Math.PI/5;
            scene.add(system);
        }
		createParticles(13, true, 1, true, 0xffffff);

		function animate(){
		  requestAnimationFrame( animate );
		  var time = Date.now();
		  windForce.set( -400, Math.abs(100*Math.sin( time / 3000 )), -Math.abs(300*Math.cos( time / 3000 )));
		  simulate( time );
		  
		  render();
		}
		animate();
		
		function render(){
		 /*使披风粒子运动*/
		 var p = cloth.particles;
		 for ( var i = 0, il = p.length; i < il; i ++ ) {
		   clothGeometry.vertices[ i ].copy( p[ i ].position );
		 }
		clothGeometry.computeFaceNormals();//重新计算线面
		clothGeometry.computeVertexNormals();//重新计算顶点
		clothGeometry.normalsNeedUpdate = true;//常熟更新
		clothGeometry.verticesNeedUpdate = true;//顶点更新
		/*使雨滴粒子运动*/
		 var vertices = system.geometry.vertices;
             vertices.forEach(function (v) {
                v.y = v.y - (v.velocityY);
                v.x = v.x - (v.velocityX);

                if (v.y <= 0) v.y = 3000;
                if (v.x <= -1000 || v.x >= 1000) v.x = 0;
            });
        geom.verticesNeedUpdate = true;
		renderer.render( scene, camera );
        }
		
		</script>
	</body>
</html>
